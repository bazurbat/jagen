#!/bin/sh

if [ "$1" = '-q' ]; then
    shift
    pkg_query="${1:?}"
    pkg_name="${2:?}"
    pkg_config="$3"
    # do not print anything else to allow usage in scripts
    jagen_debug=
else
    pkg_name="${1:?}"
    pkg_stage="${2:?}"
    pkg_config="$3"
    shift 3
    pkg_args="$@"
fi

. "${jagen_dir:?}/src/pkg.sh" || exit

pkg__stamp_name="${pkg_name}:${pkg_stage}${pkg_config:+:${pkg_config}}"
pkg__stamp_file="${jagen_build_dir:?}/${pkg__stamp_name}"
pkg__log_file="${jagen_log_dir:?}/${pkg__stamp_name}.log"

cd "$jagen_build_dir" || exit

[ "$pkg_stage" ] && : >"$pkg__log_file"

pkg_work_dir="${jagen_build_dir:?}/$pkg_name"
pkg_build_dir="${pkg_work_dir}${pkg_config:+/$pkg_config}"

# override global env and set initial values for pkg env
if [ "$pkg_config" ]; then
    import "config/$pkg_config"
fi

# include scripts
include "$jagen_include_dir/$(pkg__fname "$pkg_name")" || exit
if [ "$pkg_config" ]; then
    include "$jagen_include_dir/$(pkg__fname "$pkg_name" "$pkg_config")" || exit
    # assign "pkg__<config>__export_*" to "pkg_export_*"
    prefix="pkg__${pkg_config}__export"
    for key in $(set | sed -rn "s/^${prefix}_([[:alnum:]_]+)=.*/\1/p"); do
        eval "pkg_export_${key}=\$${prefix}_${key}" || exit
    done; unset prefix key
fi

if [ "$pkg_config" ]; then
    # append config-specific uses but filter out the toolchain to make sure its
    # included first on import
    new_use= pkg_use="$pkg_use $(eval echo \${pkg__${pkg_config}__use})"
    for use in $pkg_use; do
        if [ "$use" != "$pkg_build_toolchain" ]; then
            new_use="$new_use $use"
        fi
    done; unset use
    pkg_use=${new_use# }; unset new_use
fi

# include uses
for name in $pkg_build_toolchain $pkg_use; do
    include "$(pkg__export_fname "$name")" || exit
    if [ "$pkg_config" ]; then
        include "$(pkg__export_fname "$name" "$pkg_config")" || exit
    fi
    # assign "<name>_env_*" to "pkg_env_*" if unset
    prefix=$(jagen_name_to_id "$name")
    for key in $(set | sed -rn "s/^${prefix}_env_([[:alnum:]_]+)=.*/\1/p"); do
        eval ": \${pkg_env_${key}=\$${prefix}_env_${key}}" || exit
    done; unset prefix key
done; unset name

# remap aliases
for alias_to in $(set | sed -rn "s/^pkg_use_alias_([[:alnum:]_]+)=.*/\1/p"); do
    alias_from=$(eval echo "\$pkg_use_alias_$alias_to") || exit
    for key in $(set | sed -rn "s/^${alias_from}_([[:alnum:]_]+)=.*/\1/p"); do
        eval "${alias_to}_${key}=\$${alias_from}_${key}" || exit
    done; unset key
done; unset alias_to alias_from

if [ "$pkg_build_toolchain" ]; then
    name="$(jagen_name_to_id "$pkg_build_toolchain")"
    # assign "<toolchain name>_*" to "toolchain_*"
    for key in $(set | sed -rn "s/^${name}_([[:alnum:]_]+)=.*/\1/p"); do
        eval "toolchain_${key}=\$${name}_${key}" || exit
    done; unset name key
    # assign some "toolchain_*" to "pkg_build_*" if unset
    for key in $(set | sed -rn '/^toolchain_(env|cflags|cxxflags|ldflags)/! s/^toolchain_([[:alnum:]_]+)=.*/\1/p'); do
        eval ": \${pkg_build_${key}=\$toolchain_${key}}" || exit
    done; unset key
    # concatenate cflags
    use_env cflags
fi

# useful pkg-specific variables for scripts
pkg_install_dir="$pkg_install_root$pkg_install_prefix"

if [ "$pkg_build_system" ]; then
    pkg_toolchain_prefix=${pkg_build_system}-
fi

# defaults
: ${pkg_build_generator=$jagen_cmake_generator}
: ${pkg_build_cmake_module_path=$jagen_cmake_module_path}

# set pkg_env_* in the environment, collecting names for later expand
for name in $(set | sed -rn 's/^pkg_env_([[:alnum:]_]+)=.*/\1/p'); do
    eval "export $name=\"\$pkg_env_$name\"" || exit
    pkg__expand_names=${pkg__expand_names}${jagen_FS}${name}
done; unset name

# expand single-quoted pkg_* and collected variables
for name in $(set | sed -rn 's/^(pkg_[[:alnum:]_]+)=.*/\1/p') $pkg__expand_names; do
    eval $name='$(jagen__expand "$(IFS= eval echo \$$name)" "$name")' || exit
done; unset name

# config-specific adjustment of pkg env
if [ "$pkg_config" ]; then
    use_env "$pkg_config"
fi

# crutches
if [ "$pkg_build_toolchain" ]; then
    if [ "$pkg_build_set_toolchain" ]; then
        use_env set_toolchain
    fi
    if [ "$pkg_build_unset_cflags" ]; then
        use_env unset_cflags
    fi
fi

# remove excessive whitespace from command lines, helps diffing build logs
jagen__trim CFLAGS CXXFLAGS LDFLAGS

pkg__file=$(find_in_path "pkg/${pkg_name}.sh")
if [ "$pkg__file" ]; then
    include "$pkg__file" || exit
fi; unset pkg__file

if [ "$pkg_query" ]; then
    case $pkg_query in
        work_dir)
            printf '%s\n' "$pkg_work_dir" ;;
        source_dir)
            printf '%s\n' "$pkg_source_dir" ;;
        build_dir)
            printf '%s\n' "$pkg_build_dir" ;;
        install_dir)
            printf '%s\n' "$pkg_install_dir" ;;
    esac
    exit 0
fi

case $pkg_stage in
    unpack)
        cd "$jagen_build_dir"
        ;;
    patch)
        if [ "$pkg_source_dir" ] && [ -d "$pkg_source_dir" ]; then
            pkg_run cd "$pkg_source_dir"
        fi
        ;;
    *)
        if [ "$pkg_build_dir" ]; then
            pkg_run mkdir -p "$pkg_build_dir"
            pkg_run cd "$pkg_build_dir"
        fi
        in_flags ccache && use_env ccache
        ;;
esac

run_stage() {
    local stage pkg
    stage=$(echo "$1" | sed 's/-/_/')
    pkg="$pkg_name${pkg_config:+ ($pkg_config)}"

    if is_function "$stage"; then
        debug "$pkg: $stage"
        eval "$stage" $pkg_args >>"$pkg__log_file" 2>&1 ||
            die "failed to run $pkg_stage stage of package $pkg"
    else
        return 2
    fi
}

run_stage "jagen_pkg_${pkg_stage}_${pkg_config}" ||
    run_stage "jagen_pkg_${pkg_stage}"

touch "$pkg__stamp_file"
