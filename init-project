#!/bin/sh

set -eu

env_file="env.sh"
config_file="config.sh"

jagen_dir=$(dirname "$0")

message() {
    echo init-project: $*
}

die() {
    message $*
    exit 1
}

show_usage() {
    cat <<EOF
Usage: init-project [OPTIONS...] [PRODUCT] [LAYERS...]

  -a                   add flag
  -f                   use force
  -h                   show usage
  --help               show this help
  -s, --share-sources  share sources between projects
  --share-dist         share dist files between projects
  --share-toolchains   share toolchains between projects

EOF
}

show_help() {
    cat <<EOF
Usage: init-project [OPTIONS...] [PRODUCT] [LAYERS...]
       init-project [-h]
       init-project [-l]

  Initializes current directory as Jagen project.

SYNOPSIS:

  The script will put an environment file 'env.sh' and a configuration file
  'config.sh' in the current directory. The environment file should be sourced
  into the working shell before issuing any other Jagen commands. The
  configuration file contains project-specific settings and is sourced by a
  generator and a build system.

  The list of project layers is constructed from non-option arguments. Each
  layer can contribute rule definitions and environment overrides to the
  project.

  The project directory can also be called "build root" for a family of
  packages. A layout for a typical build root is described below:

    /bin     -- generated helper scripts
    /build   -- build system logs and working directories
    /host    -- install root for 'host' configuration
    /include -- package-specific include scripts generated from rules
    /src     -- checked out sources for SCM packages
    /target  -- install root for 'target' configuration

  The layout can differ depending on the configuration. These directories can
  be removed and re-created during the normal operation according the commands
  given. It is not safe to store important data inside the build root.

  Mixing environments from different projects (sourcing env.sh into the same
  shell) is not supported.

OPTIONS:

  -a                   add flag
  -f                   use force
  -h                   show usage
  --help               show this help
  -s, --share-sources  share sources between projects
  --share-dist         share dist files between projects
  --share-toolchains   share toolchains between projects

  Source packages, software distributions, patches and toolchains are located
  inside the project by default. To share them between different projects use
  '--share-...' options. If the share argument is given the corresponding
  component will be searched one directory level higher relative to the current
  project. Note that 'jagen clean' command does remove those directories even
  if they are inside the project root.

  The 'init-project' command refuses to initialize non-empty directories by
  default. Use '-f' option to override the check.

  The generated environment binds the project to the corresponding jagen source
  directory. If one or the other is moved or sourced from different root from
  which it was originally initialized (like chroot or Docker container) any
  build-related command will likely produce wrong results.

  The generated configuration can be adjusted manually but will be overwritten
  by the next 'init-project' invocation. Use '-a' option to set 'jagen_flags'
  at the initialization time; it can be specified multiple times.

EXAMPLES:

    # assuming jagen is checked out into ~/work
    cd ~/work
    mkdir ast100
    cd ast100
    ../jagen/init-project ast100 -a flag1 -a flag2
    . ./env.sh
    jagen build
    exit

  For subsequent invocations:

    cd ~/work/ast100
    . ./env.sh
    jagen build -f target1 target2

EOF
}

write_env() {
    cat >"$env_file" <<EOF
#!/bin/sh

jagen_relative_dir="$jagen_dir"

jagen_dir=\$(cd "\$jagen_relative_dir"; pwd -P)
jagen_project_dir=\$(pwd -P)
export jagen_dir jagen_project_dir

. "\$jagen_dir/env.sh"; sts=\$?
if [ \$sts != 0 ]; then
    echo "Error: failed to load jagen environment"
    return \$sts
fi

add_PATH "\$jagen_dir/bin"
add_PATH "\$jagen_project_dir/bin"
EOF
}

write_config() {
    cat >"$config_file" <<EOF
# jagen_dir         - refers to the jagen source directory
# jagen_project_dir - refers to the current project directory

# A list of directories containing layers used by this project.
# The list items should be newline (\\n) or tab (\\t) separated because normal
# spaces (including the indentation) are assumed to be a part of the pathname.
jagen_layers="${jagen_layers-}"

# A directory for package sources.
jagen_src_dir="$jagen_src_dir"

# A directory for downloaded distribution files.
jagen_dist_dir="$jagen_dist_dir"

# A directory for shared toolchains.
jagen_toolchains_dir="$jagen_toolchains_dir"

# Space separated list of optional features.
#   ccache  - wrap compilation commands with ccache
#   debug   - build debugging tools
#   devenv  - enable features pertinent to development environment
#   offline - skip network operations
jagen_flags="${jagen_flags-}"

# Space separated list of package names excluded from cleaning and updating.
# Example: jagen_source_exclude="chicken karaoke-player"
jagen_source_exclude=""

# Global build profile.
# Available values: release|debug|release_with_debug
jagen_build_profile="release"
EOF
}

check_path() {
    local path="$1"

    [ "$path" = .  ] && return # ignore to allow initializing empty projects

    if [ "$path" = .. ]; then
        die "invalid layer path '$path'"
    fi

    if ! [ -d "$path" ]; then
        die "the specified layer path is not exists or not a directory: $path"
    fi

    if [ "${init_jagen_layers-}" ]; then
        init_jagen_layers="$init_jagen_layers $path"
    else
        init_jagen_layers="$path"
    fi
}

parse_command_line() {
    local eoa=

    while [ $# -gt 0 ]; do
        case $1 in
            --) eoa=1 ;;
            -*) if [ "${eoa:-}" ]; then
                    check_path "$1"
                else
                    case $1 in
                        -h)
                            show_usage; exit 0 ;;
                        --help)
                            show_help; exit 0 ;;
                        -s|--share|--share-sources)
                            share_sources=1 ;;
                        --share-dist)
                            share_dist=1 ;;
                        --share-toolchains)
                            share_toolchains=1 ;;
                        -f|--force)
                            use_force=1 ;;
                        -a|--flag)
                            if [ "${jagen_flags-}" ]; then
                                jagen_flags="$jagen_flags $2"
                            else
                                jagen_flags="$2"
                            fi
                            shift ;;
                        *)
                            die "invalid option: '$1'"
                    esac
                fi ;;
             *) check_path "$1" ;;
        esac
        shift
    done
}

on_layer_init_error() {
    message "layer '$layer' init failed with status: $?"
}

do_init() {
    if [ $# = 0 ]; then
        show_usage; exit 0
    fi

    parse_command_line "$@"

    if [ -z "${use_force-}" -a "$(printf *)" != '*' ]; then
        die "not initializing non-empty directory without force"
    fi

    if [ "${share_sources-}" ]; then
        jagen_src_dir='$jagen_project_dir/../src'
    else
        jagen_src_dir='$jagen_project_dir/src'
    fi

    if [ "${share_dist-}" ]; then
        jagen_dist_dir='$jagen_project_dir/../dist'
    else
        jagen_dist_dir='$jagen_project_dir/dist'
    fi

    if [ "${share_toolchains-}" ]; then
        jagen_toolchains_dir='$jagen_project_dir/../toolchains'
    else
        jagen_toolchains_dir='$jagen_project_dir/toolchains'
    fi

    trap on_layer_init_error EXIT

    for layer in ${init_jagen_layers-}; do
        if [ -f "$layer/init.sh" ]; then
            . "$layer/init.sh"
        fi
    done

    trap - EXIT

    # prepend jagen_layers in case it was set by layer init
    init_jagen_layers="${jagen_layers-} ${init_jagen_layers-}"

    # construct newline-separated list of layers -- it looks prettier in
    # the config and allows having spaces in the paths
    jagen_layers="
"
    for layer in ${init_jagen_layers-}; do
        jagen_layers="${jagen_layers-}$layer
"
    done

    write_env || exit
    write_config "$config_file" || exit

    if ! [ -f "lib/rules.lua" ]; then
        mkdir -p lib
        cat >"lib/rules.lua" <<EOF
-- local rules for $(basename "$PWD")
EOF
fi

    . ./env.sh || exit
    jagen refresh
}

do_init "$@"
