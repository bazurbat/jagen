#!/bin/sh

set -eu

env_file="env.sh"
config_file="config.sh"

message() {
    echo init-project: $*
}

die() {
    message $*
    exit 1
}

real_path() {
    echo $(cd "${1:?}"; pwd -P)
}

show_help() {
    cat <<EOF
Usage: init-project <CONFIG> [OPTIONS...]
       init-project [-h]
       init-project [-l]

  Initializes current directory as jagen project.

SYNOPSIS:

  The script will put an environment file 'env.sh' and a configuration file
  'config.sh' in the current directory. The environment file should be sourced
  into the working shell before issuing any other jagen commands. The
  configuration file is sourced by a generator and a build system.

  Jagen will create and remove few directories inside the build root depending
  on the selected configuration and commands given, so it is not safe to store
  important data there. Also initializing jagen's own project directory as
  build root is not supported. It is recommended to use separate directory for
  every configuration and do not mix shell environments from different
  projects.

OPTIONS:

  -a  add flag
  -h  show this help
  -l  list built-in products
  -s  share sources between projects
  -f  use force

  In the default configuration a location of software distributions, patches
  and toolchains is set relative to a root directory (one level above checked
  out Jagen sources by default) to facilitate sharing between different
  projects. Source packages are checked out into the 'src' subdirectory of the
  current project. Use the '-s' option to set a location of source packages
  relative to the root directory too. Note that 'jagen clean' command does not
  touch the source packages location even if it is inside the build root.

  The command refuses to initialize non-empty directories by default. Use '-f'
  option to override the check.

  The generated environment binds the project to the corresponding jagen source
  directory. If one or the other is moved or sourced from different root from
  which it was originally initialized (like chroot or Docker container) any
  build-related command will likely produce wrong results.

  The generated configuration can be adjusted manually but will be overwritten
  by the next 'init-project' invocation. Use '-a' option to set 'jagen_flags'
  at the initialization time; it can be specified multiple times.

EXAMPLES:

    # assuming jagen is checked out into ~/work
    cd ~/work
    mkdir ast100
    cd ast100
    ../jagen/init-project ast100 -a flag1 -a flag2
    . ./env.sh
    jagen build
    exit

  For subsequent invocations:

    cd ~/work/ast100
    . ./env.sh
    jagen build -f target1 target2

EOF
}

list_products() {
    cd "$jagen_dir/usr/product"
    for cfg_dir in *; do
        echo $cfg_dir
    done
}

write_env() {
    cat >"$env_file" <<EOF
#!/bin/sh

jagen_relative_dir="$jagen_dir"

jagen_dir=\$(cd "\$jagen_relative_dir"; pwd -P)
jagen_project_dir=\$(pwd -P)
export jagen_dir jagen_project_dir

. "\$jagen_dir/env.sh"; sts=\$?
if [ \$sts != 0 ]; then
    echo "Error: failed to load jagen environment"
    return \$sts
fi

add_PATH "\$jagen_dir/bin"
add_PATH "\$jagen_project_dir/bin"
EOF
}

write_config() {
    cat >"$config_file" <<EOF
# jagen_dir         - refers to the jagen source directory
# jagen_project_dir - refers to the current project directory

# A list of directories containing layers used by this project.
# NOTE: separate items with newlines (\\n) or tabs (\\t), spaces ( ) are
# assumed to be part of the pathname, so the indentation will be counted too.
jagen_layers="$jagen_layers"

# Toplevel working directory.
# Note: using relative path allows sourcing this configuration both from
# outside and inside the chrooted container.
jagen_root_dir=\$(real_path "\$jagen_dir/..")

# A directory for downloaded distribution files.
jagen_dist_dir="\$jagen_root_dir/dist"

# A directory where unpacked toolchains are kept.
jagen_toolchains_dir="\$jagen_root_dir/toolchains"

# A directory where source packages will be checked out.
jagen_src_dir="$jagen_src_dir"

# Space separated list of optional features.
#   ccache  - wrap compilation commands with ccache
#   debug   - build debugging tools
#   devenv  - enable features pertinent to development environment
#   offline - skip network operations
jagen_flags="$jagen_flags"

# Space separated list of package names excluded from cleaning and updating.
# Example: jagen_source_exclude="chicken karaoke-player"
jagen_source_exclude=""

# Global build type.
# Available values: release|debug|release_with_debug
jagen_build_profile="release"
EOF
}

parse_names() {
    local i=

   for i in "$@"; do
        if [ "$i" = . ] || [ "$i" = .. ]; then
            die "invalid layer path value '$i'"
        fi
    done

    if [ $# -gt 1 ]; then
        init_jagen_layers="$@"
    else
        # if an argument does not contain '/' it will remain unchanged;
        # otherwise it will become empty after the substitution
        if [ "${1%%*/*}" = "$1" ]; then
            jagen_product="$1"
        else
            init_jagen_layers="$1"
        fi
    fi
}

parse_command_line() {
    local eoa=

    while [ $# -gt 0 ]; do
        if [ "$eoa" ]; then
            parse_names "$@"
            break
        else
            case $1 in
                --) eoa=1 ;;
                -h|--help)
                    show_help; exit 0 ;;
                -l|--list-products)
                    list_products; exit 0 ;;
                -s|--share)
                    share_sources=1 ;;
                -f|--force)
                    use_force=1 ;;
                -a|--flag) 
                    if [ "$jagen_flags" ]; then
                        jagen_flags="$jagen_flags $2"
                    else
                        jagen_flags="$2"
                    fi
                    shift ;;
                 *) eoa=1
                    parse_names "$@"
                    break ;;
            esac
        fi
        shift
    done
}

jagen_dir=$(dirname $0)
jagen_project_dir=''
jagen_product=''
jagen_flags=''
jagen_layers=
init_jagen_layers=

if [ $# = 0 ]; then
    show_help
    exit 0
fi

parse_command_line "$@"

if [ -z "${use_force-}" -a "$(printf *)" != '*' ]; then
    die "not initializing non-empty directory without force"
fi

if [ "$jagen_product" ]; then
    jagen_product_dir="$jagen_dir/usr/product/$jagen_product"
    [ -d "$jagen_product_dir" ] ||
        die "product '$jagen_product' was not found in $(dirname "$jagen_product_dir")"

    init_jagen_layers="$jagen_product_dir"
fi

if [ "${share_sources-}" ]; then
    jagen_src_dir='$jagen_root_dir/src'
else
    jagen_src_dir='$jagen_project_dir/src'
fi

on_layer_init_error() {
    message "layer '$layer' init failed with status: $?"
}

trap on_layer_init_error EXIT

for layer in $init_jagen_layers; do
    if [ -f "$layer/init.sh" ]; then
        . "$layer/init.sh" ||
            die "layer '$layer' init failed with status: $?"
    fi
done

trap - EXIT

if ! [ "$jagen_layers" ] && [ "$init_jagen_layers" ]; then
    jagen_layers=$(printf '\n '); jagen_layers=${jagen_layers% }
    for layer in $init_jagen_layers; do
        jagen_layers="$jagen_layers$(printf '%s\n' "$layer")
"
    done
fi

write_env || exit
write_config "$config_file" || exit

. ./env.sh || exit
jagen refresh
