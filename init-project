#!/bin/sh

set -eu

env_file="env.sh"
config_file="config.sh"

jagen_dir=$(dirname "$0")
jagen_flags=
jagen_layers=
init_jagen_layers=

message() {
    echo init-project: $*
}

die() {
    message $*
    exit 1
}

real_path() {
    echo $(cd "${1:?}"; pwd -P)
}

show_usage() {
    cat <<EOF
Usage: init-project [OPTIONS...] [PRODUCT] [LAYERS...]

  -a                   add flag
  -f                   use force
  -h                   show usage
  --help               show this help
  -l                   list built-in products
  -s, --share-sources  share sources between projects
  --share-dist         share dist files between projects
  --share-toolchains   share toolchains between projects

EOF
}

show_help() {
    cat <<EOF
Usage: init-project [OPTIONS...] [PRODUCT] [LAYERS...]
       init-project [-h]
       init-project [-l]

  Initializes current directory as Jagen project.

SYNOPSIS:

  The script will put an environment file 'env.sh' and a configuration file
  'config.sh' in the current directory. The environment file should be sourced
  into the working shell before issuing any other Jagen commands. The
  configuration file contains project-specific settings and is sourced by a
  generator and a build system.

  The list of project layers is constructed from non-option arguments or
  appended to the initial value set in the specified product template. Each
  layer can contribute rule definitions and environment overrides to the
  project.

  The project directory can also be called "build root" for a family of
  packages. A layout for a typical build root is described below:

    /bin     -- generated helper scripts
    /build   -- build system logs and working directories
    /host    -- install root for 'host' configuration
    /include -- package-specific include scripts generated from rules
    /src     -- checked out sources for SCM packages
    /target  -- install root for 'target' configuration

  The layout can differ depending on the configuration. These directories can
  be removed and re-created during the normal operation according the commands
  given. It is not safe to store important data inside the build root.

  Mixing environments from different projects (sourcing env.sh into the same
  shell) is not supported.

OPTIONS:

  -a                   add flag
  -f                   use force
  -h                   show usage
  --help               show this help
  -l                   list built-in products
  -s, --share-sources  share sources between projects
  --share-dist         share dist files between projects
  --share-toolchains   share toolchains between projects

  Source packages, software distributions, patches and toolchains are located
  inside the project by default. To share them between different projects use
  '--share-...' options. If the share argument is given the corresponding
  component will be searched one directory level higher relative to the current
  project. Note that 'jagen clean' command does remove those directories even
  if they are inside the project root.

  The 'init-project' command refuses to initialize non-empty directories by
  default. Use '-f' option to override the check.

  The generated environment binds the project to the corresponding jagen source
  directory. If one or the other is moved or sourced from different root from
  which it was originally initialized (like chroot or Docker container) any
  build-related command will likely produce wrong results.

  The generated configuration can be adjusted manually but will be overwritten
  by the next 'init-project' invocation. Use '-a' option to set 'jagen_flags'
  at the initialization time; it can be specified multiple times.

EXAMPLES:

    # assuming jagen is checked out into ~/work
    cd ~/work
    mkdir ast100
    cd ast100
    ../jagen/init-project ast100 -a flag1 -a flag2
    . ./env.sh
    jagen build
    exit

  For subsequent invocations:

    cd ~/work/ast100
    . ./env.sh
    jagen build -f target1 target2

EOF
}

list_products() {
    cd "$jagen_dir/usr/product"
    for cfg_dir in *; do
        echo $cfg_dir
    done
}

write_env() {
    cat >"$env_file" <<EOF
#!/bin/sh

jagen_relative_dir="$jagen_dir"

jagen_dir=\$(cd "\$jagen_relative_dir"; pwd -P)
jagen_project_dir=\$(pwd -P)
export jagen_dir jagen_project_dir

. "\$jagen_dir/env.sh"; sts=\$?
if [ \$sts != 0 ]; then
    echo "Error: failed to load jagen environment"
    return \$sts
fi

add_PATH "\$jagen_dir/bin"
add_PATH "\$jagen_project_dir/bin"
EOF
}

write_config() {
    cat >"$config_file" <<EOF
# jagen_dir         - refers to the jagen source directory
# jagen_project_dir - refers to the current project directory

# A list of directories containing layers used by this project.
# NOTE: separate items with newlines (\\n) or tabs (\\t) here because normal
# spaces ( ) are assumed to be a part of the pathname, so the indentation will
# be counted too.
jagen_layers="$jagen_layers"

# Toplevel working directory.
# Note: using relative path allows sourcing this configuration both from
# outside and inside the chrooted container.
jagen_root_dir=\$(real_path "\$jagen_dir/..")

# A directory where source packages will be checked out.
jagen_src_dir="$jagen_src_dir"

# A directory for downloaded distribution files.
jagen_dist_dir="$jagen_dist_dir"

# A directory where unpacked toolchains are kept.
jagen_toolchains_dir="$jagen_toolchains_dir"

# Space separated list of optional features.
#   ccache  - wrap compilation commands with ccache
#   debug   - build debugging tools
#   devenv  - enable features pertinent to development environment
#   offline - skip network operations
jagen_flags="$jagen_flags"

# Space separated list of package names excluded from cleaning and updating.
# Example: jagen_source_exclude="chicken karaoke-player"
jagen_source_exclude=""

# Global build type.
# Available values: release|debug|release_with_debug
jagen_build_profile="release"
EOF
}

is_product_name() {
    case $1 in
        -*|*/*) return 1 ;;
             *) return 0 ;;
    esac
}

parse_path() {
    local path="$1"

    if [ "$path" = . ] || [ "$path" = .. ]; then
        die "invalid layer path '$path'"
    fi

    if ! [ "${jagen_product-}" ] && is_product_name "$path"; then
        jagen_product="$path"
        return
    fi

    if [ "$init_jagen_layers" ]; then
        init_jagen_layers="$init_jagen_layers $path"
    else
        init_jagen_layers="$path"
    fi
}

parse_command_line() {
    local eoa=

    while [ $# -gt 0 ]; do
        case $1 in
            --) eoa=1 ;;
            -*) if [ "${eoa:-}" ]; then
                    parse_path "$1"
                else
                    case $1 in
                        -h)
                            show_usage; exit 0 ;;
                        --help)
                            show_help; exit 0 ;;
                        -l|--list-products)
                            list_products; exit 0 ;;
                        -s|--share|--share-sources)
                            share_sources=1 ;;
                        --share-dist)
                            share_dist=1 ;;
                        --share-toolchains)
                            share_toolchains=1 ;;
                        -f|--force)
                            use_force=1 ;;
                        -a|--flag)
                            if [ "$jagen_flags" ]; then
                                jagen_flags="$jagen_flags $2"
                            else
                                jagen_flags="$2"
                            fi
                            shift ;;
                        *)
                            die "invalid option: '$1'"
                    esac
                fi ;;
             *) parse_path "$1" ;;
        esac
        shift
    done
}

if [ $# = 0 ]; then
    show_usage; exit 0
fi

parse_command_line "$@"

if [ -z "${use_force-}" -a "$(printf *)" != '*' ]; then
    die "not initializing non-empty directory without force"
fi

if [ "${jagen_product-}" ]; then
    jagen_product_dir="$jagen_dir/usr/product/$jagen_product"
    [ -d "$jagen_product_dir" ] ||
        die "product '$jagen_product' was not found in $(dirname "$jagen_product_dir")"
fi

if [ "${share_sources-}" ]; then
    jagen_src_dir='$jagen_root_dir/src'
else
    jagen_src_dir='$jagen_project_dir/src'
fi

if [ "${share_dist-}" ]; then
    jagen_dist_dir='$jagen_root_dir/dist'
else
    jagen_dist_dir='$jagen_project_dir/dist'
fi

if [ "${share_toolchains-}" ]; then
    jagen_toolchains_dir='$jagen_root_dir/toolchains'
else
    jagen_toolchains_dir='$jagen_project_dir/toolchains'
fi

on_layer_init_error() {
    message "layer '$layer' init failed with status: $?"
}

trap on_layer_init_error EXIT

for layer in ${jagen_product_dir-} $init_jagen_layers; do
    if [ -f "$layer/init.sh" ]; then
        . "$layer/init.sh"
    fi
done

trap - EXIT

# prepend jagen_layers in case it was set by layer init (product)
init_jagen_layers="$jagen_layers $init_jagen_layers"

# construct newline-separated list of layers -- it looks prettier in
# the config and allows having spaces in the paths
jagen_layers="
"
for layer in $init_jagen_layers; do
    jagen_layers="$jagen_layers$layer
"
done

write_env || exit
write_config "$config_file" || exit

if ! [ -f "lib/rules.lua" ]; then
    mkdir -p lib
    cat >"lib/rules.lua" <<EOF
-- local rules for $(basename "$PWD")
EOF
fi

. ./env.sh || exit
jagen refresh
