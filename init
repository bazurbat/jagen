#!/bin/sh

set -ef

jagen_url="https://github.com/bazurbat/jagen.git"
env_file="env.sh"
config_file="config.sh"
runner_script="jagen"
NL=$(printf '\n!'); NL=${NL%!}

show_usage() {
    cat <<EOF
jagen-init

  Initialize a directory as a Jagen build root

USAGE

  curl -fsSL https://git.io/fhyEM | sh
  curl -fsSL https://git.io/fhyEM | sh -s -- [OPTIONS...] [URLs...]

  ../<jagen_dir>/init [OPTIONS...] [--] [ARGS...]

DESCRIPTION

  The script sets up the current working directory to act as a Jagen workspace
  which groups together related source code, downloaded archives, configuration
  and generated artifacts. When piped to shell it will clone the Jagen source
  repository on its own or it can be run locally by reaching out with a
  relative path to an already checked out Jagen source repository.

OPTIONS

  -h, --help     show this usage information
  -d, --dir      initialize the specified directory instead of the current
  -a, --flag     add the flag to jagen_flags
  -L             add the directory to jagen_layer_path

EOF
}

say() {
    echo "jagen-init: $*"
}

die() {
    say "error: $*" >&2
    exit 1
}

need_cmd() {
    if ! $(command -v "$1" >/dev/null); then
        die "could not find the '$1' command"
    fi
}

git_clone() {
    local url="$1" dir="$2" branch="$3"
    if ! [ -d "$dir" ]; then
        need_cmd git
        git clone --depth 1 ${branch:+--branch $branch} -- "$url" "$dir"
    fi
}

path_is_url() {
    [ "$1" != "${1#?*://?*/?*}"   ] && return # 0 if match: prot://host/dir
    [ "$1" != "${1#*/?}"          ] || return # 1 if not contains / or ends with /
    [ "$1" != "${1#git@?*:?*/?*}" ] && return # 0 if matches like git@github.com:name/dir
    [ "$1" != "${1#?*:?*/?*}"     ] && return # 0 if matches like github.com:name/dir
    return 1
}

path_depth() {
    local IFS=/ depth=0 item
    for item in $1; do
        case $item in
            '') ;;
             *) depth=$((depth+1)) ;;
        esac
    done
    echo $depth
}

common_dirname() {
    local IFS=/ result= item
    for item in $1; do
        if [ "${2#$result$item/}" != "$2" ]; then
            result=$result$item/
        elif [ "${2#$result$item}" != "$2" ]; then
            result=$result$item
        else
            break
        fi
    done
    result=${result%/}
    echo "$result"
}

relative_path() {
    local prefix suffix result level
    prefix=$(common_dirname "$1" "$2")
    result=${1#$prefix} result=${result#/} result=${result%/}
    suffix=${2#$prefix}
    level=$(path_depth "$suffix")
    # echo relative_path\($1, $2\): \<$prefix\> \<$suffix\> \[$level\] \<$result\>
    if [ $level = 0 ]; then
        result="./${result}"
    else
        while [ $level -gt 0 ]; do
            result="../$result"
            level=$((level-1))
        done
    fi
    echo $result
}

real_path() {
    if [ "$1" ]; then
        (cd "$1" && pwd -P)
    else
        pwd -P
    fi
}

parse_command_line() {
    while [ $# -gt 0 ]; do
        case $1 in
        --) eoa=1 ;;
        -h|--help)
            show_usage; exit 0 ;;
        -d|--dir)
            jagen_root_dir="$2"; shift ;;
        --skip-config)
            init_skip_config=1 ;;
        -p|--project)
            say "the option --project (-p) is not used anymore and is deprecated; the mode is now determined automatically" ;;
        -a|--flag)
            jagen_flags="$jagen_flags $2"; shift ;;
        -j|--jagen-branch)
            jagen_branch="$2"; shift ;;
        -b|--branch)
            jagen_layer_branch="$2"; shift ;;
        -f|--force)
            say "the option --force (-f) is not used anymore and is deprecated; it is now effectively always enabled" ;;
        -L)
            init_layer_path="${init_layer_path}${NL}${2}"; shift ;;
        -*)
            die "invalid option: $1" ;;
         *) init_layers="${init_layers}${NL}${1}" ;;
        esac
        shift
    done

    jagen_flags=${jagen_flags# }
    init_layer_path=${init_layer_path#$NL}
    init_layers=${init_layers#$NL}
}

write_env() {
    cat >"$env_file" <<EOF
#!/bin/sh

jagen_dir='$jagen_dir'
jagen_root_dir='$jagen_root_dir'
jagen_ninja_version='$jagen_ninja_version'
export jagen_dir jagen_root_dir jagen_ninja_version

. "\$jagen_dir/env.sh"; sts=\$?
if [ "\$sts" != 0 ]; then
    echo "Error: failed to load jagen environment"
    return \$sts
fi

add_PATH "\$jagen_dir/bin"
add_PATH "\$jagen_root_dir/bin"

EOF
}

write_runner() {
    cat >"$runner_script" <<'EOF'
#!/bin/sh
jagen_root_dir=$(cd "$(dirname "$0")" && pwd -P)
. "$jagen_root_dir/env.sh"; sts=$?
[ $sts = 0 ] || exit $sts
_jagen "$@"
EOF
    chmod +x "$runner_script"
}

write_config() {
    cat >"$config_file" <<EOF
# jagen_dir      - refers to the source directory of the Jagen itself.
# jagen_root_dir - refers to the current project directory.
EOF
    if [ "$jagen_layers" ]; then
        cat >>"$config_file" <<EOF

# A newline-separated list of directories containing layers for this project.
jagen_layers="$jagen_layers"
EOF
    fi
    if [ "$jagen_layer_path" ]; then
        cat >>"$config_file" <<EOF

# A newline-separated list of directories to search for unqualified layers.
jagen_layer_path="$jagen_layer_path"
EOF
    fi
    if [ "$jagen_project_dir" ]; then
        cat >>"$config_file" <<EOF

# A directory of the project associated with this root.
jagen_project_dir="$jagen_project_dir"
EOF
    fi
    cat >>"$config_file" <<EOF

# A directory for downloaded distribution files.
jagen_dist_dir="${jagen_dist_dir-\$jagen_root_dir/dist}"

# A directory for packages sources.
jagen_src_dir="${jagen_src_dir-\$jagen_root_dir/src}"

# A space-separated list of optional features:
#   ccache  - wrap compilation commands with ccache
#   offline - skip network operations
jagen_flags="$jagen_flags"

# A space-separated list of package names excluded from cleaning and updating.
jagen_source_exclude="$jagen_source_exclude"

# The default build profile: release|debug|release_with_debug
jagen_build_profile="${jagen_build_profile-release}"
EOF
}

main() {
    local layer path item

    jagen_dir=$(dirname "$0")

    parse_command_line "$@"

    if [ "$jagen_dir" = . ]; then
        if ! [ -t 0 ]; then # we are being piped to shell
            jagen_dir=".jagen"
        else # init can not work inside Jagen repository
            show_usage; exit 0
        fi
    else
        jagen_dir=$(real_path "$jagen_dir")
    fi

    if ! [ -t 1 ]; then # the output is not connected to a terminal
        say "running non-interactively"
        export GIT_TERMINAL_PROMPT=0
        export GIT_SSH_COMMAND="ssh -o BatchMode=yes"
    fi

    if [ "$init_layer_path" ]; then
        for item in $init_layer_path; do
            [ -d "$item" ] ||
                die "the specified layer path directory '$item' does not exist"
        done
    else
        for layer in $init_layers; do
            case $layer in
                /*|./*|../*) ;;
                *) layer="./$layer" ;;
            esac
            jagen_layers="${jagen_layers}${NL}${layer}"
        done
        init_layers=$jagen_layers
        jagen_layers=
    fi

    for layer in $init_layers; do
        case $layer in
            /*|./*|../*) [ -d "$layer" ] ||
                die "the specified layer directory '$layer' does not exist" ;;
        esac
    done

    if [ -f "jagen-rules.lua" ] ||
       ! [ -f "jagen" -o -f "env.sh" -o -f "config.sh" ] &&
       [ "$(ls)" ]
    then
        init_project=1
        : ${jagen_root_dir:=jagen-root}
    fi

    if [ "$jagen_root_dir" ]; then
        if ! [ -d "$jagen_root_dir" ]; then
            say "creating a directory '$jagen_root_dir'"
            mkdir -p "$jagen_root_dir"
            init_created_root_dir=1
        fi
    fi

    jagen_root_dir=$(real_path "$jagen_root_dir")

    if [ "$init_project" ]; then
        jagen_project_dir=$(relative_path "$(real_path)" "$jagen_root_dir")
    fi

    for layer in $init_layers; do
        case $layer in
            /*) layer=$(real_path "$layer") ;;
            ./*|../*)
                layer=$(relative_path "$(real_path "$layer")" "$jagen_root_dir") ;;
        esac
        jagen_layers="${jagen_layers}${NL}${layer}"
    done
    init_layers=$jagen_layers
    jagen_layers=

    for item in $init_layer_path; do
        case $item in
            /*) item=$(real_path "$item") ;;
             *) item=$(relative_path "$(real_path "$item")" "$jagen_root_dir") ;;
        esac
        jagen_layer_path="${jagen_layer_path}${NL}${item}"
    done
    jagen_layer_path=${jagen_layer_path:+${jagen_layer_path}${NL}}

    cd "$jagen_root_dir"

    git_clone "$jagen_url" "$jagen_dir" $jagen_branch
    jagen_dir=$(real_path "$jagen_dir")

    for layer in $init_layers; do
        if path_is_url "$layer"; then
            path=${layer##*/} path=${path%.git} path="./layer/$path"
            git_clone "$layer" "$path" $jagen_layer_branch
            layer="$path"
        fi
        jagen_layers="${jagen_layers}${NL}${layer}"
    done
    jagen_layers=${jagen_layers:+${jagen_layers}${NL}}

    if [ "$jagen_project_dir" ]; then
        say "initializing '$jagen_root_dir' as a workspace for a project in '$(real_path "$jagen_project_dir")'"
    else
        say "initializing '$jagen_root_dir' as a workspace"
    fi

    jagen_ninja_version=$(ninja --version)

    write_env
    write_runner
    if [ -z "$init_skip_config" ]; then
        if [ -f "$config_file" ]; then
            say "backing up an existing config as '${config_file}.bak'"
            cp -f "$config_file" "${config_file}.bak"
        fi
        write_config "$config_file"
    fi

    . ./env.sh
    jagen refresh
}

main "$@"
