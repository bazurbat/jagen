#!/bin/sh

set -eu

jagen_url="https://github.com/bazurbat/jagen.git"
env_file="env.sh"
config_file="config.sh"
runner_script="jagen"
FS="$(printf '\t')"

show_usage() {
    cat <<EOF
Usage: init [OPTIONS...] [--] [ARGS...]

  Initializes current directory as a Jagen project.

SYNOPSIS:

  The script should be run from the directory which you want to initialize as
  the project reaching out by a relative path to the checked out Jagen sources
  or piped to shell. It creates 'config.sh', 'env.sh' and 'jagen' files in the
  current directory.

  The generated 'config.sh' contains parameters from the 'init' command line
  (layers, flags) and other global settings. Edit it manually to adjust the
  parameters or global environment. It is sourced every time the build system
  runs. 
  
  For interactive work source the generated 'env.sh' to initialize current
  Shell environment for this project from now on. This will put 'jagen' command
  in PATH and allow Bash to autocomplete its commands and the project's
  targets. Note that mixing the environments from different projects will
  likely produce unexpected results.

  Use the 'jagen' script inside the project directory to run Jagen commands for
  this project from outside without modifying the environment. This could be
  useful to activate the build from IDEs and such.

OPTIONS:

  -h, --help     show this usage information
  -d, --dir      initialize the specified directory
  -a, --flag     add the flag to jagen_flags
  -f, --force    force to initialize non-empty directory
  -p, --project  initialize the current directory in project mode
  -L             add the directory to jagen_layer_path

  The following flags are reserved by the core:
  
    ccache  -- activate the usage of 'ccache' for all toolchain commands
    offline -- causes all operations requiring the network to fail

  Reinitializing an existing project is possible with '--force' but note that
  it will regenerate the 'config.sh'. The previous is saved as 'config.sh.bak'.
  Copy your old settings from it manually if necessary.

EOF
}

say() {
    echo "jagen-init: $*"
}

die() {
    say "$*" >&2
    exit 1
}

need_cmd() {
    if ! $(command -v "$1" >/dev/null); then
        die "could not find the '$1' command"
    fi
}

git_clone() {
    local url="${1}" dir="${2}" branch="${3-}"
    if ! [ -d "$dir" ]; then
        need_cmd git
        git clone --depth 1 ${branch:+--branch $branch} -- "$url" "$dir"
    fi
}

path_is_url() {
    [ "$1" != "${1#?*://?*/?*}"   ] && return # 0 if match: prot://host/dir
    [ "$1" != "${1#*/?}"          ] || return # 1 if not contains / or ends with /
    [ "$1" != "${1#git@?*:?*/?*}" ] && return # 0 if matches like git@github.com:name/dir
    [ "$1" != "${1#?*:?*/?*}"     ] && return # 0 if matches like github.com:name/dir
    return 1
}

real_path() {
    if [ "${1-}" ]; then
        (cd "$1" && pwd -P)
    else
        pwd -P
    fi
}

parse_command_line() {
    local eoa=

    while [ $# -gt 0 ]; do
        if [ "$eoa" ]; then
            jagen_args="${jagen_args-}${FS}${1}"
        else
            case $1 in
            --) eoa=1 ;;
            -h|--help)
                show_usage; exit 0 ;;
            -d|--dir)
                jagen_root_dir="$2"; shift ;;
            -p|--project)
                init_project=1 ;;
            -a|--flag)
                jagen_flags="${jagen_flags-} $2"; shift ;;
            -j|--jagen-branch)
                jagen_branch="$2"; shift ;;
            -b|--branch)
                jagen_layer_branch="$2"; shift ;;
            -f|--force)
                use_force=1 ;;
            -L)
                jagen_layer_path="${jagen_layer_path-} $2"; shift ;;
            -*)
                die "invalid option: $1" ;;
             *) init_jagen_layers="${init_jagen_layers-} $1" ;;
            esac
        fi
        shift
    done

    jagen_args=${jagen_args+${jagen_args#$FS}}
    jagen_flags=${jagen_flags+${jagen_flags# }}
    jagen_layer_path=${jagen_layer_path+${jagen_layer_path# }}
    init_jagen_layers=${init_jagen_layers+${init_jagen_layers# }}
}

write_env() {
    cat >"$env_file" <<EOF
#!/bin/sh

jagen_dir=$jagen_dir
jagen_root_dir=$jagen_root_dir
export jagen_dir jagen_root_dir

. "\$jagen_dir/env.sh"; sts=\$?
if [ \$sts != 0 ]; then
    echo "Error: failed to load jagen environment"
    return \$sts
fi

add_PATH "\$jagen_dir/bin"
add_PATH "\$jagen_root_dir/bin"
EOF
}

write_runner() {
    cat >"$runner_script" <<'EOF'
#!/bin/sh
jagen_root_dir=$(cd "$(dirname "$0")" && pwd -P)
. "$jagen_root_dir/env.sh"; sts=$?
[ $sts = 0 ] || exit $sts
_jagen "$@"
EOF
    chmod +x "$runner_script"
}

write_config() {
    cat >"$config_file" <<EOF
# jagen_dir         - refers to the jagen source directory
# jagen_root_dir - refers to the current project directory

EOF
    if [ "${jagen_layer_path-}" ]; then
        cat >>"$config_file" <<EOF
# A list of directories to search for unqualified layers.
jagen_layer_path="${jagen_layer_path-}"

EOF
    fi
    cat >>"$config_file" <<EOF
# A list of directories containing layers used by this project.
# The list items should be newline (\\n) or tab (\\t) separated because normal
# spaces (including the indentation) are assumed to be the part of the pathname.
jagen_layers="${jagen_layers-}"

# Space separated list of optional features.
#   ccache  - wrap compilation commands with ccache
#   offline - skip network operations
jagen_flags="${jagen_flags-}"

# A directory for downloaded distribution files.
jagen_dist_dir="${jagen_dist_dir-\$jagen_root_dir/dist}"

# A directory for package sources.
jagen_src_dir="${jagen_src_dir-\$jagen_root_dir/src}"

# Space separated list of package names excluded from cleaning and updating.
jagen_source_exclude="${jagen_source_exclude-}"

# The default build profile: release|debug|release_with_debug
jagen_build_profile="${jagen_build_profile-release}"
EOF
if [ "${jagen_project_dir-}" ]; then
    cat >>"$config_file" <<EOF

# A directory of the project associated with this root.
jagen_project_dir="$jagen_project_dir"
EOF
fi
}

on_exit() {
    if [ "${init_created_root_dir-}" ]; then
        rm -rf "$jagen_root_dir"
    fi
}

main() {
    local layer path wd="$(real_path)"
    parse_command_line "$@"

    jagen_dir=$(dirname "$0")
    if [ "$jagen_dir" = . ]; then
        if [ -t 0 ]; then
            # init can not work inside Jagen repository
            show_usage; exit 0
        fi
        # we are being piped to shell
        jagen_dir=".jagen"
    else
        jagen_dir=$(real_path "$jagen_dir")
    fi

    if ! [ -t 1 ]; then # the output is not connected to a terminal
        export GIT_TERMINAL_PROMPT=0
        export GIT_SSH_COMMAND="ssh -o BatchMode=yes"
    fi

    [ -f ".jagen-rules.lua" ] && init_project=1

    if [ "${init_project-}" ]; then
        jagen_project_dir=$wd
        use_force=1
    fi

    if [ "${init_project-}" ] || ! [ -t 0 ]; then
        # default root dir if piped or in project mode
        : "${jagen_root_dir:=jagen-root}"
    fi

    # Just do nothing on SIGINT because many shells (except Bash) do not call
    # EXIT handler when exiting due to a signal. External commands (such as
    # Git) will still receive SIGINT on CTRL-C.
    trap : INT
    trap on_exit EXIT

    if [ "${jagen_root_dir-}" ]; then
        if ! [ -d "$jagen_root_dir" ]; then
            mkdir -p "$jagen_root_dir"
            init_created_root_dir=1
        fi
        cd "$jagen_root_dir"
    fi
    jagen_root_dir=$(real_path)

    if [ -z "${use_force-}" -a "$(echo *)" != '*' ]; then
        die "not initializing non-empty directory without force"
    fi

    git_clone "$jagen_url" "$jagen_dir" ${jagen_branch-}
    jagen_dir=$(real_path "$jagen_dir")

    for layer in ${init_jagen_layers-}; do
        if path_is_url "$layer"; then
            path=${layer##*/} path=${path%.git} path="./layer/$path"
            git_clone "$layer" "$path" ${jagen_layer_branch-}
            layer="$path"
        fi
        jagen_layers="${jagen_layers-}$layer
"
    done
    if [ "${jagen_layers-}" ]; then
        jagen_layers="
$jagen_layers"
    fi

    if [ "${jagen_flags#*-ccache}" != "$jagen_flags" ]; then
        jagen_flags=$(echo "$jagen_flags" | sed 's/ \?-ccache \?/ /')
    elif [ "${jagen_flags#*ccache}" = "$jagen_flags" ] &&
         [ "$(command -v ccache 2>/dev/null)" ]; then
        jagen_flags="$jagen_flags ccache"
    fi
    jagen_flags=${jagen_flags# }
    jagen_flags=${jagen_flags% }

    write_env
    write_runner
    if [ -f "$config_file" ]; then
        say "backing up the existing config as ${config_file}.bak"
        cp -f "$config_file" "${config_file}.bak"
    fi
    write_config "$config_file"

    if [ -z "${jagen_args-}" ]; then
        jagen_args='refresh'
    fi

    # at this point we consider the root successfully created and not try to
    # delete if the later refresh fails
    trap - INT EXIT

    . ./env.sh || exit
    (
        IFS="$FS"
        jagen $jagen_args
    )
}

main "$@"
