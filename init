#!/bin/sh

set -ef

jagen_url="https://github.com/bazurbat/jagen.git"
env_file="env.sh"
config_file="config.sh"
runner_script="jagen"
NL=$(printf '\n!'); NL=${NL%!}

show_usage() {
    cat <<EOF
jagen-init

  Initialize a directory as a Jagen build root

USAGE

  curl -fsSL https://git.io/fhyEM | sh
  curl -fsSL https://git.io/fhyEM | sh -s -- [OPTIONS...]

  ../<jagen_dir>/init [OPTIONS...]

DESCRIPTION

  The script sets up the current working directory to act as a Jagen workspace,
  which groups together related source code, downloaded archives,
  configuration, and generated artifacts. When piped to a shell, it will clone
  the Jagen source repository on its own, or it can be run locally by reaching
  out with a relative path to an already checked out Jagen source repository.

OPTIONS

  -h, --help     show this usage information
  -a, --flag     add an optional feature to the workspace
  -L             add a directory to the layers search path

EOF
}

say() {
    echo "jagen-init: $*"
}

die() {
    say "error: $*" >&2
    exit 1
}

need_cmd() {
    if ! $(command -v "$1" >/dev/null); then
        die "could not find the '$1' command"
    fi
}

git_clone() {
    local url="$1" dir="$2" branch="$3"
    if ! [ -d "$dir" ]; then
        need_cmd git
        git clone --depth 1 ${branch:+--branch $branch} -- "$url" "$dir"
    fi
}

path_is_url() {
    [ "$1" != "${1#?*://?*/?*}"   ] && return # 0 if match: prot://host/dir
    [ "$1" != "${1#*/?}"          ] || return # 1 if not contains / or ends with /
    [ "$1" != "${1#git@?*:?*/?*}" ] && return # 0 if matches like git@github.com:name/dir
    [ "$1" != "${1#?*:?*/?*}"     ] && return # 0 if matches like github.com:name/dir
    return 1
}

real_path() {
    if [ "$1" ]; then
        (cd "$1" && pwd)
    else
        pwd
    fi
}

parse_command_line() {
    while [ $# -gt 0 ]; do
        case $1 in
        -h|--help)
            show_usage; exit 0 ;;
        --skip-config)
            init_skip_config=1 ;;
        -p|--project)
            [ "$2" ] || die "the --project (-p) option requires a directory argument"
            jagen_project_dir="$2"; shift ;;
        -a|--flag)
            [ "$2" ] || die "the --flag (-f) option requires an argument"
            jagen_flags="$jagen_flags $2"; shift ;;
        -j|--jagen-branch)
            [ "$2" ] || die "the --jagen-branch (-j) option requires a branch name argument"
            jagen_branch="$2"; shift ;;
        -b|--branch)
            [ "$2" ] || die "the --branch (-b) option requires a branch name argument"
            jagen_layer_branch="$2"; shift ;;
        -f|--force)
            say "the option --force (-f) is not used anymore and is deprecated; it is now effectively always enabled" ;;
        -L)
            [ "$2" ] || die "the -L option requires a directory argument"
            init_layer_path="${init_layer_path}${NL}${2}"; shift ;;
        -*)
            die "invalid option: $1" ;;
         *) init_layers="${init_layers}${NL}${1}" ;;
        esac
        shift
    done

    jagen_flags=${jagen_flags# }
    init_layer_path=${init_layer_path#$NL}
    init_layers=${init_layers#$NL}
}

say_init() {
    local for_project
    if [ "$jagen_project_dir" ]; then
        for_project=" for a project in $jagen_project_dir ($(real_path "$jagen_project_dir"))"
    fi

    if [ -f "$env_file" -a -f "$config_file" ]; then
        say "reinitializing an existing Jagen workspace in $jagen_root_dir$for_project"
    else
        say "initializing a new Jagen workspace in $jagen_root_dir$for_project"
    fi
}

write_env() {
    cat >"$env_file" <<EOF
#!/bin/sh

jagen_dir='$jagen_dir'
jagen_root_dir='$jagen_root_dir'
jagen_ninja_version='$jagen_ninja_version'
export jagen_dir jagen_root_dir jagen_ninja_version

. "\$jagen_dir/env.sh"; sts=\$?
if [ "\$sts" != 0 ]; then
    echo "Error: failed to load jagen environment"
    return \$sts
fi

add_PATH "\$jagen_dir/bin"
add_PATH "\$jagen_root_dir/bin"

EOF
}

write_runner() {
    cat >"$runner_script" <<'EOF'
#!/bin/sh
. "$(dirname "$0")/env.sh" && _jagen "$@"
EOF
    chmod +x "$runner_script"
}

write_config() {
    cat >"$config_file" <<EOF
# jagen_root_dir - refers to the location of the current build root
EOF
    if [ "$jagen_layers" ]; then
        cat >>"$config_file" <<EOF

# A newline-separated list of directories containing layers for this project.
jagen_layers="$jagen_layers"
EOF
    fi
    if [ "$jagen_layer_path" ]; then
        cat >>"$config_file" <<EOF

# A newline-separated list of directories to search for unqualified layers.
jagen_layer_path="$jagen_layer_path"
EOF
    fi
    if [ "$jagen_project_dir" ]; then
        cat >>"$config_file" <<EOF

# A directory of the project associated with this root.
jagen_project_dir="$jagen_project_dir"
EOF
    fi
    cat >>"$config_file" <<EOF

# A directory for downloaded distribution files.
jagen_dist_dir="${jagen_dist_dir-\$jagen_root_dir/dist}"

# A directory for packages sources.
jagen_src_dir="${jagen_src_dir-\$jagen_root_dir/src}"

# A space-separated list of optional features:
#   ccache  - wrap compilation commands with ccache
#   offline - skip network operations
jagen_flags="$jagen_flags"

# A space-separated list of package names excluded from cleaning and updating.
jagen_source_exclude="$jagen_source_exclude"

# The default build profile: release|debug|release_with_debug
jagen_build_profile="${jagen_build_profile-release}"
EOF
}

main() {
    local layer path item

    need_cmd ninja

    parse_command_line "$@"

    jagen_dir=$(dirname "$0")
    jagen_root_dir=$(real_path)
    jagen_ninja_version=$(ninja --version)

    if [ "$jagen_dir" = . ]; then
        if ! [ -t 0 ]; then # we are being piped to shell
            jagen_dir=".jagen"
        else # init can not work inside Jagen repository
            show_usage; exit 0
        fi
    fi

    if [ "$jagen_project_dir" ]; then
        [ -d "$jagen_project_dir" ] ||
            die "the specified project directory '$jagen_project_dir' does not exist"
    fi

    for item in $init_layer_path; do
        [ -d "$item" ] ||
            die "the specified layer path directory '$item' does not exist"
    done

    for layer in $init_layers; do
        case $layer in
            /*|./*|../*) [ -d "$layer" ] ||
                die "the specified layer directory '$layer' does not exist" ;;
        esac
    done

    if ! [ -t 1 ]; then # the output is not connected to a terminal
        say "running non-interactively"
        export GIT_TERMINAL_PROMPT=0
        export GIT_SSH_COMMAND="ssh -o BatchMode=yes"
    fi

    git_clone "$jagen_url" "$jagen_dir" $jagen_branch
    jagen_dir=$(real_path "$jagen_dir")

    for layer in $init_layers; do
        if path_is_url "$layer"; then
            path=${layer##*/} path=${path%.git} path="./layer/$path"
            git_clone "$layer" "$path" $jagen_layer_branch
            layer="$path"
        fi
        jagen_layers="${jagen_layers}${NL}${layer}"
    done
    jagen_layers=${jagen_layers:+${jagen_layers}${NL}}

    say_init
    write_env
    write_runner

    if [ -z "$init_skip_config" ]; then
        if [ -f "$config_file" ]; then
            say "backing up an existing ${config_file} as ${config_file}.bak"
            cp -f "$config_file" "${config_file}.bak"
        fi
        write_config "$config_file"
    fi

    . ./env.sh
    jagen refresh
}

main "$@"
